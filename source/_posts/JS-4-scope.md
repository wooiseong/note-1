---
title: Javascript-4-那個函數展開的領域 —— 作用域
excerpt: 學習函數，就必須要知道函數變量訪問的原則，才不會造成變量污染或者訪問不到變量的囧況。
tags: [Javascript, 函數, 作用域] 
categories: [Javascript]
date: 2025-01-02 21:08:27
---

關於函數的基本介紹可以看回這篇：[Javascript-3-數據類型(三) 複雜數據(函數)](http://localhost:4000/2025/01/01/JS-3-complex-md/)。

# 1.1. 前言
當我們開始使用函數時，常常遇到兩種報錯：
<br>

（一）想要訪問for loop裏的`i`
```javascript
for (let i = 0; i < 10; i++) {
  console.log('wawawa')
}
console.log(i)
```
本來想在函數外訪問函數内部變量，結果無法顯示，反而報錯：
![](/img/JS/JS-4-1.png)  
<br>

（二） 訪問函數裏的變量
```javascript
function fn(){
  let num = 1
}
fn()
console.log(num)
```
![](/img/JS/JS-4-2.png)  
<br>

用原話翻譯上面的報錯，就是 `i` 和 `num` 這兩個變量沒有被聲明，所以無法訪問。
<br>

咦，在for loop和函數不是已經聲明了嗎？為什麼還會報錯呢？
<br>
<font size="5">**因爲這和作用域有關。**</font>

# 1.2. 作用域

一段代碼不是總有效和可用的，限定這個可用性的代碼範圍的就是<font color="#46A3FF">**作用域**</font>。

要理解這個概念，可以通過《咒術迴戰》的領域展開。


![「新陰流·簡易領域」](/img/JS/JS-4-3.jpg) 

> <font color="#9D9D9D">術師展開特定空間領域範圍，只要對手身處該領域中，對手必敗。</font>

換句話説，對象必須在領域裏，術式才會生效。
<br>

同理，函數的變量也是在函數的“領域”裏才可以被訪問，這個“領域”就是作用域。

作用域提高了程序邏輯的局部性。因此，哪怕起了同樣名稱的變量，只要作用域不同，互不干擾。

作用域可以分類兩類：**全局作用域**和**局部作用域**。

## 1.2.1. 全局作用域
作用域所有代碼執行的環境，也就是一整個Javascipt文件，或則html中的 `script` 標簽之間。

```javascript
<script>
  let num = 1
  function fn(){
    console.log(num)
  }
  fn() // 1
</script>
```

舉例來説，上面的 `num` 是在 `script` 標簽裏聲明和複製的，是全局作用域，所以函數 `fn` 可以訪問到這個 `num`。

### 1.2.1. 局部作用域
只作用於函數的代碼環境，也被稱爲函數作用域

上面的例子（二）就是典型的局部作用域。
![](/img/JS/JS-4-4.jpg) 

`num` 只可以在函數 `fn` 被訪問（括號之間），函數外無法訪問。

### 1.2.1.1 特殊情況
可是有一個特殊情況，可以從外部訪問到函數内部的變量：
```javascript
function fn(){
  num = 1
}
fn()
console.log(num) //1
```
<br>
<font size="5">😵‍💫😵‍💫😵‍💫 ???</font>

不是才説函數内部變量無法在外部被訪問？
<br>

{% note info %}
其實這是一個變量的坑。如果函數内部，變量沒有被聲明，直接賦值，被當成<font color="#46A3FF">**全局變量**</font>。
{% endnote %}
<br>

這樣訪問的方式就違背作用域的作用了，可能會造成混亂，不鼓勵這樣做。

## 1.2.1.2 函數的形參
除了函數内部的變量，形參也同樣只作用于函數內部，外部無法直接訪問。
```javascript
function fn(x){
  return x
}
fn(1)
console.log(x) // x is not defined
```
![](/img/JS/JS-4-5.png) 

# 1.3 變量訪問原則
瞭解了作用域的作用範圍，代碼查找變量時遵循以下原則：

- 只要有代碼一定有作用域
- 創建函數時，會在函數内部形成局部作用域
- 函數中還有函數，這個作用域又產生新的作用域
- 函數內部可以訪問外部的變量，外部無法訪問內部的變量
- 在能訪問的情況下, <font color="#46A3FF">**先找局部，局部沒有再找全局**</font>
<br>
<br>

```javascript
let num = 1
function fn1(){
  let num = 2
  function fn2(){
    let num = 3
    console.log(num)
  }
}
fn1() //3
```

外部有一個全局作用域, `fn1` 函數有一個局部作用域，裏面的 `fn2` 又有一個局部作用域。

`fn2` 執行的時候，先找自己的局部作用域， `let num = 3` ，所以就會停止查找，顯示 `3` 。
<br>

如果注釋 `fn2` 的 `let num = 3` 呢？
![](/img/JS/JS-4-6.jpg) 

就找上一層的局部作用域，`fn1`聲明的 `let num = 2`，顯示 `2` 。

如果 `fn1` 的 `let num = 2` 被注釋，再找上一層的局部作用域，依此類推，直到找到全局作用域。

<br>
<br>
我們學習到這裏，我們學習的都是具名函數，還有匿名函數。下一篇會詳談，敬請期待。



