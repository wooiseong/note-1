---
title: Javascript-34- Javascript的原型（一） 編程思想 
excerpt: 本篇討論Javascript的編程思想。
tags: [Javascript, Contructor] 
categories: [Javascript]
date: 2025-01-19 15:51:12
---

## 1. 前言
學編程的朋友一定多少聽説很多編程的術語，像是 “OOP”, “面相對象” 和 “原型”之類的專有名詞。這些都和編程思想有關係。

身爲前端工程師，我們需要對Javascript的編程思想有一定瞭解，這樣對於深入瞭解Javascript和框架都有很好的幫助。

而且，編程思想也是面試時最常問到的問題之一。

那我們開始吧！

## 2. 編程思想
- 什麽是面相過程 （Procedure Oriented Programing-POP）？

面向過程是指分析解決問題的步驟，用函數一步一步實現，使用時再一個個調用它們。

我們擧個例子，當我們要做炒飯，

我們可以把步驟拆解成小步驟：煮飯 > 切菜 > 炒蛋 > 炒飯 > 調味

我們在編程時也是這樣經歷面相過程，按照分析的步驟，一步步實現功能。

- 什麽是面相對象 （Object Oriented Programing-OOP）？

面相對象是把任務拆解成一個個小對象，然後由對象之間相互合作。

擧個例子，我們要準備一個團體報告，

就會有人負責簡介，有人負責方法，有人負責結果，再把它們整合成一份完整的報告。

可以看到OOP和POP的不同就是，OOP是以對象功能分劃問題，而不是步驟。每個對象都有明確的分工。

由此可見，面相對象編程具有靈活，代碼復用的特性，也比較容易維護和開發，也是大型項目比較推崇的方式。

面相對象具有三個特性： 封裝性，繼承性，多態性。

### 2.1. 封裝性
封裝就是把數據的屬性和對數據的操作方法封裝在一起，

數據被保護在内部，程序只能通過被授權的操作才可以對内部數據進行操作。

### 2.2. 繼承性
繼承增加代碼的復用性。當有多個對象存在相同的屬和方法，可以從中抽取出父類。

只需要通過extends關鍵字聲明繼承父類就可以了。

### 2.3. 多態性
一個屬性或者方法有多種形態，父類的引用指向子類的對象，

不同對象即使通過同個父類的引用，參數相同，最終的表現行爲是不一樣的。
<br>

我們可以比較面相過程和面相對象的不同：
|       | 面相過程 | 面相對象 |
| :-----| :----: | :----: |
| 優點 | 性能比較高，適合跟硬件聯係緊密的任務 | 易維護，復用和擴展。可以設計出低耦合的系統，便於維護 |
| 缺點 | 難維護，復用和擴展 | 性能比較低 |
<br>

可是，知道面相過程和面相對象，跟Javascript有什麽關係呢？

因爲Javascript面向對象通過構造函數來實現面相對象的三個特性。

## 3. 構造函數
我們學過構造函數可以創建新對象，讓新對象有屬性和方法。

```javascript
function Star(uname, age) {
    this.uname = uname
    this.age = age
    this.sing = function() {
        console.log('我會唱歌')
    }
}

const ldh = new Person('劉德華', 18)
const zxy = new Person('張學友', 20)
```

同樣的構造函數，把公用屬性和方法集合在一起（封裝性），通過 `this` 讓對象繼承（繼承性）`uname` , `age` 和 `sing` 。

創建的對象 `ldh` 和 `zxy` 之間是相互獨立的，所以它們之間沒有關係，也互不影響（多態性），

當然 `ldh` 和 `zxy` 的 `sing` 方法是不一樣的，雖然在我們看來，這兩個方法的結構都是一模一樣的。

也就是說，我們通過 `Star` 構造函數每創建一個新對象，就會在内存的棧開一個新的地址，指向堆的方法。

![](/img/JS/JS-34-1.png)

一百個新對象就是一百個新方法，一百個新地址！<font size="5">😶 </font>

因此造成性能浪費的問題。
<br>

如果我們想要新創建的對象的方法都是來自同一個方法呢？我們需要藉助原型的來實現。

下一篇會詳談原型的概念，敬請期待。
<br>